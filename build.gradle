import org.gradle.nativeplatform.NativeDependencySet

plugins {
    id 'base'
    id 'maven-publish'
    id "com.jfrog.artifactory" version "4.29.3"
    id 'edu.wpi.first.NativeUtils' version '2023.10.0'
    id 'cpp'
    id 'c'
}

publishing {
  repositories {
    if (project.hasProperty('releaseRepoPublish')) {
      maven {
        url "${System.getProperty('user.home')}/releases/maven/release"
      }
    } else {
      maven {
        url "${System.getProperty('user.home')}/releases/maven/development"
      }
    }
  }
}

if (System.getenv()['RUN_AZURE_ARTIFACTORY_RELEASE'] != null) {
  artifactory {
    contextUrl = 'https://frcmaven.wpi.edu/artifactory' // base artifactory url
    publish {
      repository {
        if (project.hasProperty('releaseRepoPublish')) {
          repoKey = 'release'
        } else {
          repoKey = 'development'
        }
        username = System.getenv()['ARTIFACTORY_PUBLISH_USERNAME']
        password = System.getenv()['ARTIFACTORY_PUBLISH_PASSWORD']
        maven = true
      }
      defaults {
          publications ('chipobject', 'netcomm', 'runtime', 'visa')
      }
    }
  }
  publish.dependsOn artifactoryPublish
}

nativeUtils.addWpiNativeUtils()
nativeUtils.withCrossRoboRIO()

nativeUtils.wpi.addWarnings()
nativeUtils.wpi.addWarningsAsErrors()

nativeUtils.setSinglePrintPerPlatform()

nativeUtils.platformConfigs.linuxathena.linker.args.add("-Wl,--fatal-warnings")

nativeUtils.crossCompilers.named(nativeUtils.wpi.platforms.roborio) { c ->
    c.optional.set(false)
}

class FileDependencySet implements NativeDependencySet {
    private FileCollection linkFiles;
    private FileCollection emptySet

    FileDependencySet(FileCollection files, FileCollection emptySet) {
        linkFiles = files
        this.emptySet = emptySet
    }

    @Override
    FileCollection getIncludeRoots() {
        return emptySet
    }

    @Override
    FileCollection getLinkFiles() {
        return linkFiles
    }

    @Override
    FileCollection getRuntimeFiles() {
        return emptySet
    }
}

def netCommDependencySet = new FileDependencySet(project.files(
    'src/lib/netcomm/libFRC_NetworkCommunication.so.23.0.0',
    'src/lib/chipobject/libRoboRIO_FRC_ChipObject.so.23.0.0',
    'src/lib/visa/libvisa.so.22.5.0'),
    project.files())

model {
    components {
        test(NativeExecutableSpec) {
            targetPlatform nativeUtils.wpi.platforms.roborio
            sources {
                cpp {
                    source {
                        srcDirs 'src/test'
                        include '**/*.cpp'
                    }
                    exportedHeaders {
                        srcDirs 'src/include'
                    }
                }
            }
            binaries.all {
                linker.args '-ldl'
                lib netCommDependencySet
                lib library: 'embcanshim', linkage: 'shared'
                lib library: 'fpgalvshim', linkage: 'shared'
            }
        }
        embcanshim(NativeLibrarySpec) {
            targetPlatform nativeUtils.wpi.platforms.roborio
            sources {
                c {
                    source {
                        srcDirs 'src/shims/embcan'
                        include '**/*.c'
                    }
                }
            }
            binaries.all {
                tasks.withType(LinkSharedLibrary) {
                    installName = 'libnirio_emb_can.so.21'
                }
            }
        }
        fpgalvshim(NativeLibrarySpec) {
            targetPlatform nativeUtils.wpi.platforms.roborio
            sources {
                c {
                    source {
                        srcDirs 'src/shims/fpgalv'
                        include '**/*.c'
                    }
                }
            }
            binaries.all {
                tasks.withType(LinkSharedLibrary) {
                    installName = 'libNiFpgaLv.so.13'
                }
            }
        }
    }
    binaries {
        withType(NativeBinarySpec).all {
            nativeUtils.usePlatformArguments(it)
        }
        withType(StaticLibraryBinarySpec).all {
            buildable = false
        }
    }
}

apply from: 'config.gradle'

def allOutputsFolder = file("$buildDir/allOutputs")

if (project.hasProperty('releaseRepoPublish')) {
  allOutputsFolder = file("$buildDir/allOutputsRelease")
}

task copyAllOutputs(type: Copy) {
    destinationDir = allOutputsFolder
}

build.dependsOn copyAllOutputs

ext.addTaskToCopyAllOutputs = { task ->
    copyAllOutputs.dependsOn task
    copyAllOutputs.inputs.file task.archivePath
    copyAllOutputs.from task.archivePath
}

def pubVersion = '2023.2.1'

def baseArtifactId = 'chipobject'
def artifactGroupId = 'edu.wpi.first.ni-libraries'
def zipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_chipobject_CLS'

def netcommBaseArtifactId = 'netcomm'
def netcommZipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_netcomm_CLS'

def runtimeBaseArtifactId = 'runtime'
def runtimeZipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_runtime_CLS'

def visaBaseArtifactId = 'visa'
def visaZipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_visa_CLS'

def outputsFolder = file("$project.buildDir/outputs")

def versionFile = file("$outputsFolder/version.txt")

task outputVersions() {
    description = 'Prints the versions of this to a file for use by the downstream packaging project'
    group = 'Build'
    outputs.files(versionFile)

    doFirst {
        buildDir.mkdir()
        outputsFolder.mkdir()
    }

    doLast {
        versionFile.write pubVersion
    }
}

build.dependsOn outputVersions
copyAllOutputs.dependsOn outputVersions
copyAllOutputs.inputs.file versionFile
copyAllOutputs.from versionFile

task libZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    classifier = "linuxathena"

    from('src/lib/chipobject') {
        into '/linux/athena/shared/'
    }
}

task libZipDebug(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    classifier = "linuxathenadebug"

    from('src/lib/chipobject') {
        into '/linux/athena/shared/'
    }
}

task headersZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    classifier = "headers"

    from('src/include/FRC_FPGA_ChipObject') {
        into '/FRC_FPGA_ChipObject'
    }
}

task visaLib(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = visaZipBaseName
    classifier = "linuxathena"

    from('src/lib/visa') {
        into '/linux/athena/shared/'
    }
}

task visaLibDebug(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = visaZipBaseName
    classifier = "linuxathenadebug"

    from('src/lib/visa') {
        into '/linux/athena/shared/'
    }
}

task visaHeaders(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = visaZipBaseName
    classifier = "headers"

    from ('src/include/visa') {
        into '/visa'
    }
}

task netCommLib(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = netcommZipBaseName
    classifier = "linuxathena"

    from('src/lib/netcomm') {
        into '/linux/athena/shared/'
    }
}

task netCommLibDebug(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = netcommZipBaseName
    classifier = "linuxathenadebug"

    from('src/lib/netcomm') {
        into '/linux/athena/shared/'
    }
}

task netCommHeaders(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = netcommZipBaseName
    classifier = "headers"

    from('src/include/FRC_NetworkCommunication') {
        into '/FRC_NetworkCommunication'
    }
}

task runtimeLib(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = runtimeZipBaseName
    classifier = "linuxathena"
}

task runtimeLibDebug(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = runtimeZipBaseName
    classifier = "linuxathenadebug"
}

task imageZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = runtimeZipBaseName
    classifier = "allowedimages"

    from('allowed_images.txt')
}

build.dependsOn netCommLib
build.dependsOn headersZip
build.dependsOn netCommHeaders
build.dependsOn libZip
build.dependsOn libZipDebug
build.dependsOn netCommLibDebug
build.dependsOn visaLib
build.dependsOn visaLibDebug
build.dependsOn visaHeaders
build.dependsOn runtimeLib
build.dependsOn runtimeLibDebug
build.dependsOn imageZip

addTaskToCopyAllOutputs(netCommLib)
addTaskToCopyAllOutputs(headersZip)
addTaskToCopyAllOutputs(libZip)
addTaskToCopyAllOutputs(netCommHeaders)
addTaskToCopyAllOutputs(libZipDebug)
addTaskToCopyAllOutputs(netCommLibDebug)
addTaskToCopyAllOutputs(runtimeLib)
addTaskToCopyAllOutputs(runtimeLibDebug)

addTaskToCopyAllOutputs(visaLib)
addTaskToCopyAllOutputs(visaLibDebug)
addTaskToCopyAllOutputs(visaHeaders)

addTaskToCopyAllOutputs(imageZip)

model {
    publishing {
        def taskList = createComponentZipTasks($.components, ['embcanshim', 'fpgalvshim'], 'DoNotPublishRuntime', Zip, project, includeStandardZipFormat)
    }
}

publishing {
    publications {
        chipobject(MavenPublication) {
            artifact libZip
            artifact headersZip
            artifact libZipDebug

            artifactId = "${baseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
        netcomm(MavenPublication) {
            artifact netCommLib
            artifact netCommHeaders
            artifact netCommLibDebug

            artifactId = "${netcommBaseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
        visa(MavenPublication) {
            artifact visaLib
            artifact visaHeaders
            artifact visaLibDebug

            artifactId = "${visaBaseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
        runtime(MavenPublication) {
            artifact runtimeLib
            artifact runtimeLibDebug
            artifact imageZip

            artifactId = "${runtimeBaseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
    }
}

task patchNiLibraries() {
    doLast {
        // Patch ChipObject headers to be self contained
        FileTree chipTree = fileTree(dir: "$rootDir/src/include/FRC_FPGA_ChipObject/nRoboRIO_FPGANamespace")
        chipTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('#include \"tSystemInterface.h\"', '#include \"../tSystem.h\"\n#include \"../tSystemInterface.h\"')
            file.write(contents, 'UTF-8')
        }

        // Patch HMB header to be rooted correctly
        File hmbFile = file("$rootDir/src/include/FRC_FPGA_ChipObject/fpgainterfacecapi/NiFpga_HMB.h")
        hmbFile.text = hmbFile.text.replaceAll('#include "fpgainterfacecapi/NiFpga.h"', '#include "FRC_FPGA_ChipObject/fpgainterfacecapi/NiFpga.h"')

        // Patch NetComm headers to work on Windows
        FileTree netTree = fileTree(dir: "$rootDir/src/include/FRC_NetworkCommunication")
        netTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('#ifdef WIN32', '#ifdef _WIN32')
            contents = contents.replaceAll('# include <vxWorks_compat.h>', '#include <windows.h>')
            contents = contents.replaceAll('#include <vxWorks_compat.h>', '#include <windows.h>')
            file.write(contents, 'UTF-8')
        }

        FileTree allTree = fileTree(dir: "$rootDir/src/include/")
        allTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('\r\n', '\n')
            file.write(contents, 'UTF-8')
        }
    }
}

wrapper {
    gradleVersion = '7.5.1'
}
